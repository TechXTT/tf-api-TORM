package models

// Code generated by TORM; DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"regexp"
	"strings"
	"sync"
	"time"

	_ "github.com/lib/pq"
)

// Client wraps a database connection and provides per-model services.
type Client struct {
	dsn  string
	db   *sql.DB
	once sync.Once
	err  error
}

// NewClient reads DSN from prisma/schema.prisma and returns a Client.
func NewClient() *Client {
	data, err := ioutil.ReadFile("prisma/schema.prisma")
	if err != nil {
		panic(fmt.Sprintf("cannot read schema: %v", err))
	}
	re := regexp.MustCompile(`url\s*=\s*(?:env\("([^"]+)"\)|"([^\"]+)")`)
	m := re.FindStringSubmatch(string(data))
	var dsn string
	if m[1] != "" {
		dsn = strings.Trim(os.Getenv(m[1]), "")
	} else {
		dsn = strings.Trim(m[2], "")
	}
	// disable SSL if not set
	if strings.HasPrefix(dsn, "postgres://") && !strings.Contains(dsn, "sslmode=") {
		sep := "?"
		if strings.Contains(dsn, "?") {
			sep = "&"
		}
		dsn += sep + "sslmode=disable"
	}
	return &Client{dsn: dsn}
}

// connect opens the DB once.
func (c *Client) connect() (*sql.DB, error) {
	c.once.Do(func() {
		c.db, c.err = sql.Open("postgres", c.dsn)
		if c.err != nil {
			return
		}
		c.err = c.db.PingContext(context.Background())
	})
	return c.db, c.err
}

// TimeOrZero implements sql.Scanner for time.Time fields, converting NULL to zero time.
type TimeOrZero time.Time

// Scan implements the sql.Scanner interface.
func (t *TimeOrZero) Scan(value interface{}) error {
	if value == nil {
		*t = TimeOrZero(time.Time{})
		return nil
	}
	tm, ok := value.(time.Time)
	if !ok {
		return fmt.Errorf("cannot scan type %T into TimeOrZero", value)
	}
	*t = TimeOrZero(tm)
	return nil
}

// scanDest returns a slice of destination pointers for scanning into struct fields.
// It substitutes sql.NullString for any string field, and TimeOrZero for any time.Time field.
func scanDest(m interface{}) []interface{} {
	v := reflect.ValueOf(m)
	if v.Kind() != reflect.Ptr || v.IsNil() {
		return nil
	}
	v = v.Elem()
	if v.Kind() != reflect.Struct {
		return nil
	}

	var dest []interface{}
	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldType := field.Type()

		switch fieldType {
		case reflect.TypeOf(time.Time{}):
			// Use a TimeOrZero placeholder
			var tmp TimeOrZero
			dest = append(dest, &tmp)

		case reflect.TypeOf(""):
			// Use a sql.NullString placeholder instead of a bare string
			var tmp sql.NullString
			dest = append(dest, &tmp)

		default:
			if field.CanAddr() {
				dest = append(dest, field.Addr().Interface())
			} else {
				var dummy interface{}
				dest = append(dest, &dummy)
			}
		}
	}
	return dest
}

// ProjectService provides DB operations for the Project model.
type ProjectService struct {
	db *sql.DB
}

// ProjectService returns a new service for Project.
func (c *Client) ProjectService() (*ProjectService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &ProjectService{db: db}, nil
}

// FindUnique retrieves a single Project by unique filter.
func (svc *ProjectService) FindUnique(ctx context.Context, where map[string]interface{}) (*Project, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "project", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Project
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	// load many-to-many Creator via join table creator_project
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
		rowscreators, err := svc.db.QueryContext(ctx,
			fmt.Sprintf(
				"SELECT %s FROM %s t JOIN %s jt ON t.id = jt.%s_id WHERE jt.%s_id = $1",
				strings.Join(colsRel, ", "),
				"creator",
				"creator_project",
				"creator",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowscreators.Close()
			for rowscreators.Next() {
				var related Creator
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowscreators.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.Creators = append(m.Creators, related)
				}
			}
		}
	}
	// one-to-many load of Picture
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
		rowspictures, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"picture",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowspictures.Close()
			for rowspictures.Next() {
				var related Picture
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowspictures.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.Pictures = append(m.Pictures, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsNetwork, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsNetwork.Close()
			for rowsvotesAsNetwork.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsNetwork.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsNetwork = append(m.VotesAsNetwork, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsSoftware, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsSoftware.Close()
			for rowsvotesAsSoftware.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsSoftware.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsSoftware = append(m.VotesAsSoftware, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsEmbedded, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsEmbedded.Close()
			for rowsvotesAsEmbedded.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsEmbedded.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsEmbedded = append(m.VotesAsEmbedded, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsBattleBot, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsBattleBot.Close()
			for rowsvotesAsBattleBot.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsBattleBot.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsBattleBot = append(m.VotesAsBattleBot, related)
				}
			}
		}
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Project or returns an error if not found.
func (svc *ProjectService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Project, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Project not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Project matching filters, or nil if none.
func (svc *ProjectService) FindFirst(ctx context.Context, where map[string]interface{}) (*Project, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Project
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	// load many-to-many Creator via join table creator_project
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
		rowscreators, err := svc.db.QueryContext(ctx,
			fmt.Sprintf(
				"SELECT %s FROM %s t JOIN %s jt ON t.id = jt.%s_id WHERE jt.%s_id = $1",
				strings.Join(colsRel, ", "),
				"creator",
				"creator_project",
				"creator",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowscreators.Close()
			for rowscreators.Next() {
				var related Creator
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowscreators.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.Creators = append(m.Creators, related)
				}
			}
		}
	}
	// one-to-many load of Picture
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
		rowspictures, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"picture",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowspictures.Close()
			for rowspictures.Next() {
				var related Picture
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowspictures.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.Pictures = append(m.Pictures, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsNetwork, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsNetwork.Close()
			for rowsvotesAsNetwork.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsNetwork.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsNetwork = append(m.VotesAsNetwork, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsSoftware, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsSoftware.Close()
			for rowsvotesAsSoftware.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsSoftware.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsSoftware = append(m.VotesAsSoftware, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsEmbedded, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsEmbedded.Close()
			for rowsvotesAsEmbedded.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsEmbedded.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsEmbedded = append(m.VotesAsEmbedded, related)
				}
			}
		}
	}
	// one-to-many load of Vote
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		rowsvotesAsBattleBot, err := svc.db.QueryContext(ctx,
			fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
				strings.Join(colsRel, ", "),
				"vote",
				"project",
			),
			m.Id,
		)
		if err == nil {
			defer rowsvotesAsBattleBot.Close()
			for rowsvotesAsBattleBot.Next() {
				var related Vote
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsvotesAsBattleBot.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.VotesAsBattleBot = append(m.VotesAsBattleBot, related)
				}
			}
		}
	}
	return &m, nil
}

// FindFirstOrThrow retrieves the first Project or errors if none.
func (svc *ProjectService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Project, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Project found")
	}
	return rec, nil
}

// FindMany retrieves multiple Project records matching filters.
func (svc *ProjectService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Project, error) {
	whereClause, args := buildWhere(where)
	{
		cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
		query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "project")
		if whereClause != "" {
			query += " WHERE " + whereClause
		}
		if len(orderBy) > 0 {
			query += " ORDER BY " + strings.Join(orderBy, ", ")
		}
		if take > 0 {
			query += fmt.Sprintf(" LIMIT %d", take)
		}
		if skip > 0 {
			query += fmt.Sprintf(" OFFSET %d", skip)
		}
		rows, err := svc.db.QueryContext(ctx, query, args...)
		if err != nil {
			return nil, err
		}
		defer rows.Close()
		var result []*Project
		for rows.Next() {
			var m Project
			dest := scanDest(&m)
			dest = dest[:len(cols)] // Ensure we only scan expected columns
			if err := rows.Scan(dest...); err != nil {
				return nil, err
			}
			structVal := reflect.ValueOf(&m).Elem()
			for i := 0; i < len(cols); i++ {
				switch placeholder := dest[i].(type) {
				case *sql.NullString:
					if placeholder.Valid {
						structVal.Field(i).SetString(placeholder.String)
					} else {
						structVal.Field(i).SetString("")
					}
				case *TimeOrZero:
					t := time.Time(*placeholder)
					structVal.Field(i).Set(reflect.ValueOf(t))
				}
			}
			// Load one‐level relations
			// load many-to-many Creator via join table creator_project
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
				rowscreators, err := svc.db.QueryContext(ctx,
					fmt.Sprintf(
						"SELECT %s FROM %s t JOIN %s jt ON t.id = jt.%s_id WHERE jt.%s_id = $1",
						strings.Join(colsRel, ", "),
						"creator",
						"creator_project",
						"creator",
						"project",
					),
					m.Id,
				)
				if err == nil {
					defer rowscreators.Close()
					for rowscreators.Next() {
						var related Creator
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowscreators.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.Creators = append(m.Creators, related)
						} else {
							fmt.Println("Error scanning Creator:", err)
						}
					}
				}
			}
			// one-to-many load of Picture
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
				rowspictures, err := svc.db.QueryContext(ctx,
					fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
						strings.Join(colsRel, ", "),
						"picture",
						"project",
					),
					m.Id,
				)
				if err == nil {
					defer rowspictures.Close()
					for rowspictures.Next() {
						var related Picture
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowspictures.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.Pictures = append(m.Pictures, related)
						} else {
							fmt.Println("Error scanning Picture:", err)
						}
					}
				}
			}
			// one-to-many load of Vote
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
				rowsvotesAsNetwork, err := svc.db.QueryContext(ctx,
					fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
						strings.Join(colsRel, ", "),
						"vote",
						"project",
					),
					m.Id,
				)
				if err == nil {
					defer rowsvotesAsNetwork.Close()
					for rowsvotesAsNetwork.Next() {
						var related Vote
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowsvotesAsNetwork.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.VotesAsNetwork = append(m.VotesAsNetwork, related)
						} else {
							fmt.Println("Error scanning Vote:", err)
						}
					}
				}
			}
			// one-to-many load of Vote
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
				rowsvotesAsSoftware, err := svc.db.QueryContext(ctx,
					fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
						strings.Join(colsRel, ", "),
						"vote",
						"project",
					),
					m.Id,
				)
				if err == nil {
					defer rowsvotesAsSoftware.Close()
					for rowsvotesAsSoftware.Next() {
						var related Vote
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowsvotesAsSoftware.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.VotesAsSoftware = append(m.VotesAsSoftware, related)
						} else {
							fmt.Println("Error scanning Vote:", err)
						}
					}
				}
			}
			// one-to-many load of Vote
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
				rowsvotesAsEmbedded, err := svc.db.QueryContext(ctx,
					fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
						strings.Join(colsRel, ", "),
						"vote",
						"project",
					),
					m.Id,
				)
				if err == nil {
					defer rowsvotesAsEmbedded.Close()
					for rowsvotesAsEmbedded.Next() {
						var related Vote
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowsvotesAsEmbedded.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.VotesAsEmbedded = append(m.VotesAsEmbedded, related)
						} else {
							fmt.Println("Error scanning Vote:", err)
						}
					}
				}
			}
			// one-to-many load of Vote
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
				rowsvotesAsBattleBot, err := svc.db.QueryContext(ctx,
					fmt.Sprintf("SELECT %s FROM %s WHERE %sid = $1",
						strings.Join(colsRel, ", "),
						"vote",
						"project",
					),
					m.Id,
				)
				if err == nil {
					defer rowsvotesAsBattleBot.Close()
					for rowsvotesAsBattleBot.Next() {
						var related Vote
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowsvotesAsBattleBot.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.VotesAsBattleBot = append(m.VotesAsBattleBot, related)
						} else {
							fmt.Println("Error scanning Vote:", err)
						}
					}
				}
			}
			result = append(result, &m)
		}
		return result, nil
	}
}

// Create inserts a new Project record and updates the passed model with any returned values.
func (svc *ProjectService) Create(ctx context.Context, m *Project) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["description"] = m.Description
	data["type"] = m.Type
	data["category"] = m.Category
	data["mentor"] = m.Mentor
	data["videolink"] = m.VideoLink
	data["hasthumbnail"] = m.HasThumbnail
	data["demolink"] = m.DemoLink
	data["githublink"] = m.GithubLink

	// Remove empty string entries so they won't be inserted
	for k, v := range data {
		if str, ok := v.(string); ok {
			if str == "" {
				delete(data, k)
			}
		}
	}

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "project", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Update modifies an existing Project record and updates the passed model pointer.
func (svc *ProjectService) Update(ctx context.Context, where map[string]interface{}, m *Project) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["description"] = m.Description
	data["type"] = m.Type
	data["category"] = m.Category
	data["mentor"] = m.Mentor
	data["videolink"] = m.VideoLink
	data["hasthumbnail"] = m.HasThumbnail
	data["demolink"] = m.DemoLink
	data["githublink"] = m.GithubLink

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "project", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Upsert creates or updates a Project record and updates the passed model pointer.
func (svc *ProjectService) Upsert(ctx context.Context, where map[string]interface{}, m *Project) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Project record by unique filter.
func (svc *ProjectService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "project", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Project records matching 'where'.
func (svc *ProjectService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Project records in a single statement.
func (svc *ProjectService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "project", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Project records matching 'where' and updates each passed model pointer.
func (svc *ProjectService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Project) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["name"] = m.Name
		data["description"] = m.Description
		data["type"] = m.Type
		data["category"] = m.Category
		data["mentor"] = m.Mentor
		data["videolink"] = m.VideoLink
		data["hasthumbnail"] = m.HasThumbnail
		data["demolink"] = m.DemoLink
		data["githublink"] = m.GithubLink

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "project", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		structVal := reflect.ValueOf(m).Elem()
		for i := 0; i < structVal.NumField(); i++ {
			switch placeholder := dest[i].(type) {
			case *sql.NullString:
				if placeholder.Valid {
					structVal.Field(i).SetString(placeholder.String)
				} else {
					structVal.Field(i).SetString("")
				}
			case *TimeOrZero:
				t := time.Time(*placeholder)
				structVal.Field(i).Set(reflect.ValueOf(t))
			}
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Project records.
func (svc *ProjectService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "project", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Project.
func (svc *ProjectService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Project by specified fields and computes aggregates.
func (svc *ProjectService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// CreatorService provides DB operations for the Creator model.
type CreatorService struct {
	db *sql.DB
}

// CreatorService returns a new service for Creator.
func (c *Client) CreatorService() (*CreatorService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &CreatorService{db: db}, nil
}

// FindUnique retrieves a single Creator by unique filter.
func (svc *CreatorService) FindUnique(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "creator", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	// load many-to-many Project via join table creator_project
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
		rowsProject, err := svc.db.QueryContext(ctx,
			fmt.Sprintf(
				"SELECT %s FROM %s t JOIN %s jt ON t.id = jt.%s_id WHERE jt.%s_id = $1",
				strings.Join(colsRel, ", "),
				"project",
				"creator_project",
				"project",
				"creator",
			),
			m.Id,
		)
		if err == nil {
			defer rowsProject.Close()
			for rowsProject.Next() {
				var related Project
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsProject.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.Project = append(m.Project, related)
				}
			}
		}
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Creator or returns an error if not found.
func (svc *CreatorService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Creator not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Creator matching filters, or nil if none.
func (svc *CreatorService) FindFirst(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	// load many-to-many Project via join table creator_project
	{
		colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
		rowsProject, err := svc.db.QueryContext(ctx,
			fmt.Sprintf(
				"SELECT %s FROM %s t JOIN %s jt ON t.id = jt.%s_id WHERE jt.%s_id = $1",
				strings.Join(colsRel, ", "),
				"project",
				"creator_project",
				"project",
				"creator",
			),
			m.Id,
		)
		if err == nil {
			defer rowsProject.Close()
			for rowsProject.Next() {
				var related Project
				destRel := scanDest(&related)
				destRel = destRel[:len(colsRel)]
				if err := rowsProject.Scan(destRel...); err == nil {
					// Copy scanned values into struct fields
					structValRel := reflect.ValueOf(&related).Elem()
					for i := 0; i < len(colsRel); i++ {
						switch placeholder := destRel[i].(type) {
						case *sql.NullString:
							if placeholder.Valid {
								structValRel.Field(i).SetString(placeholder.String)
							} else {
								structValRel.Field(i).SetString("")
							}
						case *TimeOrZero:
							t := time.Time(*placeholder)
							structValRel.Field(i).Set(reflect.ValueOf(t))
						}
					}
					m.Project = append(m.Project, related)
				}
			}
		}
	}
	return &m, nil
}

// FindFirstOrThrow retrieves the first Creator or errors if none.
func (svc *CreatorService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Creator found")
	}
	return rec, nil
}

// FindMany retrieves multiple Creator records matching filters.
func (svc *CreatorService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Creator, error) {
	whereClause, args := buildWhere(where)
	{
		cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
		query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "creator")
		if whereClause != "" {
			query += " WHERE " + whereClause
		}
		if len(orderBy) > 0 {
			query += " ORDER BY " + strings.Join(orderBy, ", ")
		}
		if take > 0 {
			query += fmt.Sprintf(" LIMIT %d", take)
		}
		if skip > 0 {
			query += fmt.Sprintf(" OFFSET %d", skip)
		}
		rows, err := svc.db.QueryContext(ctx, query, args...)
		if err != nil {
			return nil, err
		}
		defer rows.Close()
		var result []*Creator
		for rows.Next() {
			var m Creator
			dest := scanDest(&m)
			dest = dest[:len(cols)] // Ensure we only scan expected columns
			if err := rows.Scan(dest...); err != nil {
				return nil, err
			}
			structVal := reflect.ValueOf(&m).Elem()
			for i := 0; i < len(cols); i++ {
				switch placeholder := dest[i].(type) {
				case *sql.NullString:
					if placeholder.Valid {
						structVal.Field(i).SetString(placeholder.String)
					} else {
						structVal.Field(i).SetString("")
					}
				case *TimeOrZero:
					t := time.Time(*placeholder)
					structVal.Field(i).Set(reflect.ValueOf(t))
				}
			}
			// Load one‐level relations
			// load many-to-many Project via join table creator_project
			{
				colsRel := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink"}
				rowsProject, err := svc.db.QueryContext(ctx,
					fmt.Sprintf(
						"SELECT %s FROM %s t JOIN %s jt ON t.id = jt.%s_id WHERE jt.%s_id = $1",
						strings.Join(colsRel, ", "),
						"project",
						"creator_project",
						"project",
						"creator",
					),
					m.Id,
				)
				if err == nil {
					defer rowsProject.Close()
					for rowsProject.Next() {
						var related Project
						destRel := scanDest(&related)
						destRel = destRel[:len(colsRel)]
						if err := rowsProject.Scan(destRel...); err == nil {
							// Copy scanned values into struct fields
							structValRel := reflect.ValueOf(&related).Elem()
							for i := 0; i < len(colsRel); i++ {
								switch placeholder := destRel[i].(type) {
								case *sql.NullString:
									if placeholder.Valid {
										structValRel.Field(i).SetString(placeholder.String)
									} else {
										structValRel.Field(i).SetString("")
									}
								case *TimeOrZero:
									t := time.Time(*placeholder)
									structValRel.Field(i).Set(reflect.ValueOf(t))
								}
							}
							m.Project = append(m.Project, related)
						} else {
							fmt.Println("Error scanning Project:", err)
						}
					}
				}
			}
			result = append(result, &m)
		}
		return result, nil
	}
}

// Create inserts a new Creator record and updates the passed model with any returned values.
func (svc *CreatorService) Create(ctx context.Context, m *Creator) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["phone"] = m.Phone
	data["grade"] = m.Grade
	data["class"] = m.Class

	// Remove empty string entries so they won't be inserted
	for k, v := range data {
		if str, ok := v.(string); ok {
			if str == "" {
				delete(data, k)
			}
		}
	}

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "creator", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Update modifies an existing Creator record and updates the passed model pointer.
func (svc *CreatorService) Update(ctx context.Context, where map[string]interface{}, m *Creator) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["phone"] = m.Phone
	data["grade"] = m.Grade
	data["class"] = m.Class

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "creator", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Upsert creates or updates a Creator record and updates the passed model pointer.
func (svc *CreatorService) Upsert(ctx context.Context, where map[string]interface{}, m *Creator) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Creator record by unique filter.
func (svc *CreatorService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "creator", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Creator records matching 'where'.
func (svc *CreatorService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Creator records in a single statement.
func (svc *CreatorService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "creator", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Creator records matching 'where' and updates each passed model pointer.
func (svc *CreatorService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Creator) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["name"] = m.Name
		data["email"] = m.Email
		data["phone"] = m.Phone
		data["grade"] = m.Grade
		data["class"] = m.Class

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "creator", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		structVal := reflect.ValueOf(m).Elem()
		for i := 0; i < structVal.NumField(); i++ {
			switch placeholder := dest[i].(type) {
			case *sql.NullString:
				if placeholder.Valid {
					structVal.Field(i).SetString(placeholder.String)
				} else {
					structVal.Field(i).SetString("")
				}
			case *TimeOrZero:
				t := time.Time(*placeholder)
				structVal.Field(i).Set(reflect.ValueOf(t))
			}
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Creator records.
func (svc *CreatorService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "creator", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Creator.
func (svc *CreatorService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Creator by specified fields and computes aggregates.
func (svc *CreatorService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// PictureService provides DB operations for the Picture model.
type PictureService struct {
	db *sql.DB
}

// PictureService returns a new service for Picture.
func (c *Client) PictureService() (*PictureService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &PictureService{db: db}, nil
}

// FindUnique retrieves a single Picture by unique filter.
func (svc *PictureService) FindUnique(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "picture", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Picture
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Picture or returns an error if not found.
func (svc *PictureService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Picture not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Picture matching filters, or nil if none.
func (svc *PictureService) FindFirst(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Picture
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	return &m, nil
}

// FindFirstOrThrow retrieves the first Picture or errors if none.
func (svc *PictureService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Picture found")
	}
	return rec, nil
}

// FindMany retrieves multiple Picture records matching filters.
func (svc *PictureService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Picture, error) {
	whereClause, args := buildWhere(where)
	{
		cols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
		query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "picture")
		if whereClause != "" {
			query += " WHERE " + whereClause
		}
		if len(orderBy) > 0 {
			query += " ORDER BY " + strings.Join(orderBy, ", ")
		}
		if take > 0 {
			query += fmt.Sprintf(" LIMIT %d", take)
		}
		if skip > 0 {
			query += fmt.Sprintf(" OFFSET %d", skip)
		}
		rows, err := svc.db.QueryContext(ctx, query, args...)
		if err != nil {
			return nil, err
		}
		defer rows.Close()
		var result []*Picture
		for rows.Next() {
			var m Picture
			dest := scanDest(&m)
			dest = dest[:len(cols)] // Ensure we only scan expected columns
			if err := rows.Scan(dest...); err != nil {
				return nil, err
			}
			structVal := reflect.ValueOf(&m).Elem()
			for i := 0; i < len(cols); i++ {
				switch placeholder := dest[i].(type) {
				case *sql.NullString:
					if placeholder.Valid {
						structVal.Field(i).SetString(placeholder.String)
					} else {
						structVal.Field(i).SetString("")
					}
				case *TimeOrZero:
					t := time.Time(*placeholder)
					structVal.Field(i).Set(reflect.ValueOf(t))
				}
			}
			// Load one‐level relations
			result = append(result, &m)
		}
		return result, nil
	}
}

// Create inserts a new Picture record and updates the passed model with any returned values.
func (svc *PictureService) Create(ctx context.Context, m *Picture) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["url"] = m.Url
	data["isthumbnail"] = m.IsThumbnail
	data["projectid"] = m.ProjectId

	// Remove empty string entries so they won't be inserted
	for k, v := range data {
		if str, ok := v.(string); ok {
			if str == "" {
				delete(data, k)
			}
		}
	}

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "picture", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Update modifies an existing Picture record and updates the passed model pointer.
func (svc *PictureService) Update(ctx context.Context, where map[string]interface{}, m *Picture) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["url"] = m.Url
	data["isthumbnail"] = m.IsThumbnail
	data["projectid"] = m.ProjectId

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "picture", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Upsert creates or updates a Picture record and updates the passed model pointer.
func (svc *PictureService) Upsert(ctx context.Context, where map[string]interface{}, m *Picture) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Picture record by unique filter.
func (svc *PictureService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "picture", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Picture records matching 'where'.
func (svc *PictureService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Picture records in a single statement.
func (svc *PictureService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "picture", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Picture records matching 'where' and updates each passed model pointer.
func (svc *PictureService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Picture) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["url"] = m.Url
		data["isthumbnail"] = m.IsThumbnail
		data["projectid"] = m.ProjectId

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "picture", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		structVal := reflect.ValueOf(m).Elem()
		for i := 0; i < structVal.NumField(); i++ {
			switch placeholder := dest[i].(type) {
			case *sql.NullString:
				if placeholder.Valid {
					structVal.Field(i).SetString(placeholder.String)
				} else {
					structVal.Field(i).SetString("")
				}
			case *TimeOrZero:
				t := time.Time(*placeholder)
				structVal.Field(i).Set(reflect.ValueOf(t))
			}
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Picture records.
func (svc *PictureService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "picture", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Picture.
func (svc *PictureService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Picture by specified fields and computes aggregates.
func (svc *PictureService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// VoteService provides DB operations for the Vote model.
type VoteService struct {
	db *sql.DB
}

// VoteService returns a new service for Vote.
func (c *Client) VoteService() (*VoteService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &VoteService{db: db}, nil
}

// FindUnique retrieves a single Vote by unique filter.
func (svc *VoteService) FindUnique(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "vote", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Vote
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Vote or returns an error if not found.
func (svc *VoteService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Vote not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Vote matching filters, or nil if none.
func (svc *VoteService) FindFirst(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Vote
	dest := scanDest(&m)
	dest = dest[:len(cols)] // Ensure we only scan expected columns
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	structVal := reflect.ValueOf(&m).Elem()
	for i := 0; i < len(cols); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	// Load one‐level relations
	return &m, nil
}

// FindFirstOrThrow retrieves the first Vote or errors if none.
func (svc *VoteService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Vote found")
	}
	return rec, nil
}

// FindMany retrieves multiple Vote records matching filters.
func (svc *VoteService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Vote, error) {
	whereClause, args := buildWhere(where)
	{
		cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "vote")
		if whereClause != "" {
			query += " WHERE " + whereClause
		}
		if len(orderBy) > 0 {
			query += " ORDER BY " + strings.Join(orderBy, ", ")
		}
		if take > 0 {
			query += fmt.Sprintf(" LIMIT %d", take)
		}
		if skip > 0 {
			query += fmt.Sprintf(" OFFSET %d", skip)
		}
		rows, err := svc.db.QueryContext(ctx, query, args...)
		if err != nil {
			return nil, err
		}
		defer rows.Close()
		var result []*Vote
		for rows.Next() {
			var m Vote
			dest := scanDest(&m)
			dest = dest[:len(cols)] // Ensure we only scan expected columns
			if err := rows.Scan(dest...); err != nil {
				return nil, err
			}
			structVal := reflect.ValueOf(&m).Elem()
			for i := 0; i < len(cols); i++ {
				switch placeholder := dest[i].(type) {
				case *sql.NullString:
					if placeholder.Valid {
						structVal.Field(i).SetString(placeholder.String)
					} else {
						structVal.Field(i).SetString("")
					}
				case *TimeOrZero:
					t := time.Time(*placeholder)
					structVal.Field(i).Set(reflect.ValueOf(t))
				}
			}
			// Load one‐level relations
			result = append(result, &m)
		}
		return result, nil
	}
}

// Create inserts a new Vote record and updates the passed model with any returned values.
func (svc *VoteService) Create(ctx context.Context, m *Vote) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["verified"] = m.Verified
	data["networksid"] = m.NetworksId
	data["softwareid"] = m.SoftwareId
	data["embeddedid"] = m.EmbeddedId
	data["battlebotid"] = m.BattleBotId

	// Remove empty string entries so they won't be inserted
	for k, v := range data {
		if str, ok := v.(string); ok {
			if str == "" {
				delete(data, k)
			}
		}
	}

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "vote", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Update modifies an existing Vote record and updates the passed model pointer.
func (svc *VoteService) Update(ctx context.Context, where map[string]interface{}, m *Vote) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["verified"] = m.Verified
	data["networksid"] = m.NetworksId
	data["softwareid"] = m.SoftwareId
	data["embeddedid"] = m.EmbeddedId
	data["battlebotid"] = m.BattleBotId

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "vote", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	structVal := reflect.ValueOf(m).Elem()
	for i := 0; i < structVal.NumField(); i++ {
		switch placeholder := dest[i].(type) {
		case *sql.NullString:
			if placeholder.Valid {
				structVal.Field(i).SetString(placeholder.String)
			} else {
				structVal.Field(i).SetString("")
			}
		case *TimeOrZero:
			t := time.Time(*placeholder)
			structVal.Field(i).Set(reflect.ValueOf(t))
		}
	}
	return nil
}

// Upsert creates or updates a Vote record and updates the passed model pointer.
func (svc *VoteService) Upsert(ctx context.Context, where map[string]interface{}, m *Vote) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Vote record by unique filter.
func (svc *VoteService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "vote", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Vote records matching 'where'.
func (svc *VoteService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Vote records in a single statement.
func (svc *VoteService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "vote", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Vote records matching 'where' and updates each passed model pointer.
func (svc *VoteService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Vote) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["name"] = m.Name
		data["email"] = m.Email
		data["verified"] = m.Verified
		data["networksid"] = m.NetworksId
		data["softwareid"] = m.SoftwareId
		data["embeddedid"] = m.EmbeddedId
		data["battlebotid"] = m.BattleBotId

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "vote", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		structVal := reflect.ValueOf(m).Elem()
		for i := 0; i < structVal.NumField(); i++ {
			switch placeholder := dest[i].(type) {
			case *sql.NullString:
				if placeholder.Valid {
					structVal.Field(i).SetString(placeholder.String)
				} else {
					structVal.Field(i).SetString("")
				}
			case *TimeOrZero:
				t := time.Time(*placeholder)
				structVal.Field(i).Set(reflect.ValueOf(t))
			}
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Vote records.
func (svc *VoteService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "vote", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Vote.
func (svc *VoteService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Vote by specified fields and computes aggregates.
func (svc *VoteService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// Helper functions used by services

// buildWhere assembles SQL WHERE clause and args
func buildWhere(where map[string]interface{}) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := 1
	for k, v := range where {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, " AND "), args
}

// buildWhereOffset is like buildWhere but starts binding at offset
func buildWhereOffset(where map[string]interface{}, start int) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := start
	for k, v := range where {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, " AND "), args
}

// buildInsert assembles INSERT columns, placeholders, and args
func buildInsert(data map[string]interface{}) ([]string, []string, []interface{}) {
	var cols []string
	var placeholders []string
	var args []interface{}
	i := 1
	for k, v := range data {
		cols = append(cols, k)
		placeholders = append(placeholders, fmt.Sprintf("$%d", i))
		args = append(args, v)
		i++
	}
	return cols, placeholders, args
}

// buildSet assembles SET clause and args
func buildSet(data map[string]interface{}, start int) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := start
	for k, v := range data {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, ", "), args
}
