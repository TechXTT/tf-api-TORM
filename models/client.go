package models

// Code generated by TORM; DO NOT EDIT.

import (
	"context"
	"database/sql"
	"fmt"
	"io/ioutil"
	"os"
	"regexp"
	"strings"
	"sync"

	_ "github.com/lib/pq"
)

// Client wraps a database connection and provides per-model services.
type Client struct {
	dsn  string
	db   *sql.DB
	once sync.Once
	err  error
}

// NewClient reads DSN from prisma/schema.prisma and returns a Client.
func NewClient() *Client {
	data, err := ioutil.ReadFile("prisma/schema.prisma")
	if err != nil {
		panic(fmt.Sprintf("cannot read schema: %v", err))
	}
	re := regexp.MustCompile(`url\s*=\s*(?:env\("([^"]+)"\)|"([^\"]+)")`)
	m := re.FindStringSubmatch(string(data))
	var dsn string
	if m[1] != "" {
		dsn = strings.Trim(os.Getenv(m[1]), "")
	} else {
		dsn = strings.Trim(m[2], "")
	}
	// disable SSL if not set
	if strings.HasPrefix(dsn, "postgres://") && !strings.Contains(dsn, "sslmode=") {
		sep := "?"
		if strings.Contains(dsn, "?") {
			sep = "&"
		}
		dsn += sep + "sslmode=disable"
	}
	return &Client{dsn: dsn}
}

// connect opens the DB once.
func (c *Client) connect() (*sql.DB, error) {
	c.once.Do(func() {
		c.db, c.err = sql.Open("postgres", c.dsn)
		if c.err != nil {
			return
		}
		c.err = c.db.PingContext(context.Background())
	})
	return c.db, c.err
}

// ProjectService provides DB operations for the Project model.
type ProjectService struct {
	db *sql.DB
}

// ProjectService returns a new service for Project.
func (c *Client) ProjectService() (*ProjectService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &ProjectService{db: db}, nil
}

// FindUnique retrieves a single Project by unique filter.
func (svc *ProjectService) FindUnique(ctx context.Context, where map[string]interface{}) (*Project, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink", "creatorid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "project", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Project
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Project or returns an error if not found.
func (svc *ProjectService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Project, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Project not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Project matching filters, or nil if none.
func (svc *ProjectService) FindFirst(ctx context.Context, where map[string]interface{}) (*Project, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink", "creatorid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Project
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindFirstOrThrow retrieves the first Project or errors if none.
func (svc *ProjectService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Project, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Project found")
	}
	return rec, nil
}

// FindMany retrieves multiple Project records matching filters.
func (svc *ProjectService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Project, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink", "creatorid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	if len(orderBy) > 0 {
		query += " ORDER BY " + strings.Join(orderBy, ", ")
	}
	if take > 0 {
		query += fmt.Sprintf(" LIMIT %d", take)
	}
	if skip > 0 {
		query += fmt.Sprintf(" OFFSET %d", skip)
	}
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Project
	for rows.Next() {
		var m Project
		dest := scanDest(&m)
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		result = append(result, &m)
	}
	return result, nil
}

// Create inserts a new Project record and updates the passed model with any returned values.
func (svc *ProjectService) Create(ctx context.Context, m *Project) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["description"] = m.Description
	data["type"] = m.Type
	data["category"] = m.Category
	data["mentor"] = m.Mentor
	data["videolink"] = m.VideoLink
	data["hasthumbnail"] = m.HasThumbnail
	data["demolink"] = m.DemoLink
	data["githublink"] = m.GithubLink
	data["creatorid"] = m.CreatorId

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink", "creatorid"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "project", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	// Scan returned values back into the struct fields
	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Update modifies an existing Project record and updates the passed model pointer.
func (svc *ProjectService) Update(ctx context.Context, where map[string]interface{}, m *Project) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["description"] = m.Description
	data["type"] = m.Type
	data["category"] = m.Category
	data["mentor"] = m.Mentor
	data["videolink"] = m.VideoLink
	data["hasthumbnail"] = m.HasThumbnail
	data["demolink"] = m.DemoLink
	data["githublink"] = m.GithubLink
	data["creatorid"] = m.CreatorId

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink", "creatorid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "project", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Upsert creates or updates a Project record and updates the passed model pointer.
func (svc *ProjectService) Upsert(ctx context.Context, where map[string]interface{}, m *Project) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	// Check existence
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		// Create a new record
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		// Update existing record; ensure primary key is set on m if needed
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Project record by unique filter.
func (svc *ProjectService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "project", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Project records matching 'where'.
func (svc *ProjectService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Project records in a single statement.
func (svc *ProjectService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "project", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Project records matching 'where' and updates each passed model pointer.
func (svc *ProjectService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Project) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		// Extract new values from the struct into a map
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["name"] = m.Name
		data["description"] = m.Description
		data["type"] = m.Type
		data["category"] = m.Category
		data["mentor"] = m.Mentor
		data["videolink"] = m.VideoLink
		data["hasthumbnail"] = m.HasThumbnail
		data["demolink"] = m.DemoLink
		data["githublink"] = m.GithubLink
		data["creatorid"] = m.CreatorId

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		// Return all columns to repopulate the struct
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "description", "type", "category", "mentor", "videolink", "hasthumbnail", "demolink", "githublink", "creatorid"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "project", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Project records.
func (svc *ProjectService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "project", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Project.
func (svc *ProjectService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	// agg keys: "_count", "_avg", "_sum", "_min", "_max"
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	// Scan into generic map
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Project by specified fields and computes aggregates.
func (svc *ProjectService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "project")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// CreatorService provides DB operations for the Creator model.
type CreatorService struct {
	db *sql.DB
}

// CreatorService returns a new service for Creator.
func (c *Client) CreatorService() (*CreatorService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &CreatorService{db: db}, nil
}

// FindUnique retrieves a single Creator by unique filter.
func (svc *CreatorService) FindUnique(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "creator", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Creator or returns an error if not found.
func (svc *CreatorService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Creator not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Creator matching filters, or nil if none.
func (svc *CreatorService) FindFirst(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Creator
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindFirstOrThrow retrieves the first Creator or errors if none.
func (svc *CreatorService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Creator, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Creator found")
	}
	return rec, nil
}

// FindMany retrieves multiple Creator records matching filters.
func (svc *CreatorService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Creator, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	if len(orderBy) > 0 {
		query += " ORDER BY " + strings.Join(orderBy, ", ")
	}
	if take > 0 {
		query += fmt.Sprintf(" LIMIT %d", take)
	}
	if skip > 0 {
		query += fmt.Sprintf(" OFFSET %d", skip)
	}
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Creator
	for rows.Next() {
		var m Creator
		dest := scanDest(&m)
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		result = append(result, &m)
	}
	return result, nil
}

// Create inserts a new Creator record and updates the passed model with any returned values.
func (svc *CreatorService) Create(ctx context.Context, m *Creator) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["phone"] = m.Phone
	data["grade"] = m.Grade
	data["class"] = m.Class
	data["projectid"] = m.ProjectId

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class", "projectid"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "creator", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	// Scan returned values back into the struct fields
	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Update modifies an existing Creator record and updates the passed model pointer.
func (svc *CreatorService) Update(ctx context.Context, where map[string]interface{}, m *Creator) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["phone"] = m.Phone
	data["grade"] = m.Grade
	data["class"] = m.Class
	data["projectid"] = m.ProjectId

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class", "projectid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "creator", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Upsert creates or updates a Creator record and updates the passed model pointer.
func (svc *CreatorService) Upsert(ctx context.Context, where map[string]interface{}, m *Creator) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	// Check existence
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		// Create a new record
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		// Update existing record; ensure primary key is set on m if needed
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Creator record by unique filter.
func (svc *CreatorService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "creator", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Creator records matching 'where'.
func (svc *CreatorService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Creator records in a single statement.
func (svc *CreatorService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "creator", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Creator records matching 'where' and updates each passed model pointer.
func (svc *CreatorService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Creator) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		// Extract new values from the struct into a map
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["name"] = m.Name
		data["email"] = m.Email
		data["phone"] = m.Phone
		data["grade"] = m.Grade
		data["class"] = m.Class
		data["projectid"] = m.ProjectId

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		// Return all columns to repopulate the struct
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "phone", "grade", "class", "projectid"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "creator", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Creator records.
func (svc *CreatorService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "creator", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Creator.
func (svc *CreatorService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	// agg keys: "_count", "_avg", "_sum", "_min", "_max"
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	// Scan into generic map
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Creator by specified fields and computes aggregates.
func (svc *CreatorService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "creator")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// PictureService provides DB operations for the Picture model.
type PictureService struct {
	db *sql.DB
}

// PictureService returns a new service for Picture.
func (c *Client) PictureService() (*PictureService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &PictureService{db: db}, nil
}

// FindUnique retrieves a single Picture by unique filter.
func (svc *PictureService) FindUnique(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "picture", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Picture
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Picture or returns an error if not found.
func (svc *PictureService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Picture not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Picture matching filters, or nil if none.
func (svc *PictureService) FindFirst(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Picture
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindFirstOrThrow retrieves the first Picture or errors if none.
func (svc *PictureService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Picture, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Picture found")
	}
	return rec, nil
}

// FindMany retrieves multiple Picture records matching filters.
func (svc *PictureService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Picture, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	if len(orderBy) > 0 {
		query += " ORDER BY " + strings.Join(orderBy, ", ")
	}
	if take > 0 {
		query += fmt.Sprintf(" LIMIT %d", take)
	}
	if skip > 0 {
		query += fmt.Sprintf(" OFFSET %d", skip)
	}
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Picture
	for rows.Next() {
		var m Picture
		dest := scanDest(&m)
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		result = append(result, &m)
	}
	return result, nil
}

// Create inserts a new Picture record and updates the passed model with any returned values.
func (svc *PictureService) Create(ctx context.Context, m *Picture) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["url"] = m.Url
	data["isthumbnail"] = m.IsThumbnail
	data["projectid"] = m.ProjectId

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "picture", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	// Scan returned values back into the struct fields
	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Update modifies an existing Picture record and updates the passed model pointer.
func (svc *PictureService) Update(ctx context.Context, where map[string]interface{}, m *Picture) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["url"] = m.Url
	data["isthumbnail"] = m.IsThumbnail
	data["projectid"] = m.ProjectId

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "picture", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Upsert creates or updates a Picture record and updates the passed model pointer.
func (svc *PictureService) Upsert(ctx context.Context, where map[string]interface{}, m *Picture) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	// Check existence
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		// Create a new record
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		// Update existing record; ensure primary key is set on m if needed
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Picture record by unique filter.
func (svc *PictureService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "picture", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Picture records matching 'where'.
func (svc *PictureService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Picture records in a single statement.
func (svc *PictureService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "picture", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Picture records matching 'where' and updates each passed model pointer.
func (svc *PictureService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Picture) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		// Extract new values from the struct into a map
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["url"] = m.Url
		data["isthumbnail"] = m.IsThumbnail
		data["projectid"] = m.ProjectId

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		// Return all columns to repopulate the struct
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "url", "isthumbnail", "projectid"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "picture", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Picture records.
func (svc *PictureService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "picture", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Picture.
func (svc *PictureService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	// agg keys: "_count", "_avg", "_sum", "_min", "_max"
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	// Scan into generic map
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Picture by specified fields and computes aggregates.
func (svc *PictureService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "picture")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// VoteService provides DB operations for the Vote model.
type VoteService struct {
	db *sql.DB
}

// VoteService returns a new service for Vote.
func (c *Client) VoteService() (*VoteService, error) {
	db, err := c.connect()
	if err != nil {
		return nil, fmt.Errorf("connect: %w", err)
	}
	return &VoteService{db: db}, nil
}

// FindUnique retrieves a single Vote by unique filter.
func (svc *VoteService) FindUnique(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("SELECT %s FROM %s WHERE %s LIMIT 1", strings.Join(cols, ", "), "vote", whereClause)
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Vote
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindUniqueOrThrow retrieves a single Vote or returns an error if not found.
func (svc *VoteService) FindUniqueOrThrow(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	rec, err := svc.FindUnique(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("Vote not found")
	}
	return rec, nil
}

// FindFirst retrieves a single Vote matching filters, or nil if none.
func (svc *VoteService) FindFirst(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var m Vote
	dest := scanDest(&m)
	if err := row.Scan(dest...); err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
}

// FindFirstOrThrow retrieves the first Vote or errors if none.
func (svc *VoteService) FindFirstOrThrow(ctx context.Context, where map[string]interface{}) (*Vote, error) {
	rec, err := svc.FindFirst(ctx, where)
	if err != nil {
		return nil, err
	}
	if rec == nil {
		return nil, fmt.Errorf("no Vote found")
	}
	return rec, nil
}

// FindMany retrieves multiple Vote records matching filters.
func (svc *VoteService) FindMany(ctx context.Context, where map[string]interface{}, orderBy []string, skip, take int) ([]*Vote, error) {
	whereClause, args := buildWhere(where)
	cols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(cols, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	if len(orderBy) > 0 {
		query += " ORDER BY " + strings.Join(orderBy, ", ")
	}
	if take > 0 {
		query += fmt.Sprintf(" LIMIT %d", take)
	}
	if skip > 0 {
		query += fmt.Sprintf(" OFFSET %d", skip)
	}
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var result []*Vote
	for rows.Next() {
		var m Vote
		dest := scanDest(&m)
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		result = append(result, &m)
	}
	return result, nil
}

// Create inserts a new Vote record and updates the passed model with any returned values.
func (svc *VoteService) Create(ctx context.Context, m *Vote) error {
	// Extract values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["verified"] = m.Verified
	data["networksid"] = m.NetworksId
	data["softwareid"] = m.SoftwareId
	data["embeddedid"] = m.EmbeddedId
	data["battlebotid"] = m.BattleBotId

	cols, placeholders, args := buildInsert(data)
	colsList := strings.Join(cols, ", ")
	phList := strings.Join(placeholders, ", ")
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s) RETURNING %s", "vote", colsList, phList, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	// Scan returned values back into the struct fields
	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Update modifies an existing Vote record and updates the passed model pointer.
func (svc *VoteService) Update(ctx context.Context, where map[string]interface{}, m *Vote) error {
	// Extract new values from the struct into a map
	data := make(map[string]interface{})
	data["createdat"] = m.CreatedAt
	data["updatedat"] = m.UpdatedAt
	data["deletedat"] = m.DeletedAt
	data["name"] = m.Name
	data["email"] = m.Email
	data["verified"] = m.Verified
	data["networksid"] = m.NetworksId
	data["softwareid"] = m.SoftwareId
	data["embeddedid"] = m.EmbeddedId
	data["battlebotid"] = m.BattleBotId

	setClause, setArgs := buildSet(data, 1)
	whereClause, whereArgs := buildWhereOffset(where, len(setArgs)+1)
	args := append(setArgs, whereArgs...)
	// Return all columns to repopulate the struct
	allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "vote", setClause, whereClause, strings.Join(allCols, ", "))
	row := svc.db.QueryRowContext(ctx, query, args...)

	dest := scanDest(m)
	if err := row.Scan(dest...); err != nil {
		return err
	}
	return nil
}

// Upsert creates or updates a Vote record and updates the passed model pointer.
func (svc *VoteService) Upsert(ctx context.Context, where map[string]interface{}, m *Vote) error {
	tx, err := svc.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}
	// Check existence
	existing, err := svc.FindUnique(ctx, where)
	if err != nil {
		tx.Rollback()
		return err
	}
	if existing == nil {
		// Create a new record
		if err := svc.Create(ctx, m); err != nil {
			tx.Rollback()
			return err
		}
	} else {
		// Update existing record; ensure primary key is set on m if needed
		if err := svc.Update(ctx, where, m); err != nil {
			tx.Rollback()
			return err
		}
	}
	if err := tx.Commit(); err != nil {
		return err
	}
	return nil
}

// Delete removes a Vote record by unique filter.
func (svc *VoteService) Delete(ctx context.Context, where map[string]interface{}) error {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "vote", whereClause)
	_, err := svc.db.ExecContext(ctx, query, args...)
	return err
}

// Count returns the number of Vote records matching 'where'.
func (svc *VoteService) Count(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT COUNT(*) FROM %s", "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, err
	}
	return count, nil
}

// CreateMany inserts multiple Vote records in a single statement.
func (svc *VoteService) CreateMany(ctx context.Context, data []map[string]interface{}) (int64, error) {
	if len(data) == 0 {
		return 0, nil
	}
	cols, _, _ := buildInsert(data[0])
	var placeholders []string
	var args []interface{}
	index := 1
	for _, row := range data {
		var ph []string
		for _, col := range cols {
			args = append(args, row[col])
			ph = append(ph, fmt.Sprintf("$%d", index))
			index++
		}
		placeholders = append(placeholders, fmt.Sprintf("(%s)", strings.Join(ph, ", ")))
	}
	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES %s", "vote", strings.Join(cols, ", "), strings.Join(placeholders, ", "))
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// UpdateMany modifies multiple Vote records matching 'where' and updates each passed model pointer.
func (svc *VoteService) UpdateMany(ctx context.Context, where []map[string]interface{}, ms []*Vote) (int64, error) {
	if len(where) != len(ms) {
		return 0, fmt.Errorf("mismatch between filter list and model list length")
	}
	var totalAffected int64 = 0
	for i, m := range ms {
		filter := where[i]
		// Extract new values from the struct into a map
		data := make(map[string]interface{})
		data["createdat"] = m.CreatedAt
		data["updatedat"] = m.UpdatedAt
		data["deletedat"] = m.DeletedAt
		data["name"] = m.Name
		data["email"] = m.Email
		data["verified"] = m.Verified
		data["networksid"] = m.NetworksId
		data["softwareid"] = m.SoftwareId
		data["embeddedid"] = m.EmbeddedId
		data["battlebotid"] = m.BattleBotId

		setClause, setArgs := buildSet(data, 1)
		whereClause, whereArgs := buildWhereOffset(filter, len(setArgs)+1)
		args := append(setArgs, whereArgs...)
		// Return all columns to repopulate the struct
		allCols := []string{"id", "createdat", "updatedat", "deletedat", "name", "email", "verified", "networksid", "softwareid", "embeddedid", "battlebotid"}
		query := fmt.Sprintf("UPDATE %s SET %s WHERE %s RETURNING %s", "vote", setClause, whereClause, strings.Join(allCols, ", "))
		row := svc.db.QueryRowContext(ctx, query, args...)

		dest := scanDest(m)
		if err := row.Scan(dest...); err != nil {
			return totalAffected, err
		}
		totalAffected++
	}
	return totalAffected, nil
}

// DeleteMany removes multiple Vote records.
func (svc *VoteService) DeleteMany(ctx context.Context, where map[string]interface{}) (int64, error) {
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("DELETE FROM %s WHERE %s", "vote", whereClause)
	res, err := svc.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, err
	}
	return res.RowsAffected()
}

// Aggregate computes SQL aggregates for Vote.
func (svc *VoteService) Aggregate(ctx context.Context, where map[string]interface{}, agg map[string][]string) (map[string]interface{}, error) {
	// agg keys: "_count", "_avg", "_sum", "_min", "_max"
	selectClauses := []string{}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	row := svc.db.QueryRowContext(ctx, query, args...)
	// Scan into generic map
	cols := strings.Split(strings.Join(selectClauses, ", "), ", ")
	vals := make([]interface{}, len(cols))
	result := map[string]interface{}{}
	dest := []interface{}{}
	for range vals {
		var v interface{}
		dest = append(dest, &v)
	}
	if err := row.Scan(dest...); err != nil {
		return nil, err
	}
	for i, col := range cols {
		parts := strings.Split(col, " AS ")
		alias := strings.TrimSpace(parts[1])
		result[alias] = *(dest[i].(*interface{}))
	}
	return result, nil
}

// GroupBy groups Vote by specified fields and computes aggregates.
func (svc *VoteService) GroupBy(ctx context.Context, by []string, where map[string]interface{}, agg map[string][]string) ([]map[string]interface{}, error) {
	groupClause := strings.Join(by, ", ")
	selectClauses := []string{}
	for _, g := range by {
		selectClauses = append(selectClauses, g)
	}
	for key, fields := range agg {
		for _, f := range fields {
			selectClauses = append(selectClauses, fmt.Sprintf("%s(%s) AS %s_%s", strings.TrimPrefix(key, "_"), f, key, f))
		}
	}
	whereClause, args := buildWhere(where)
	query := fmt.Sprintf("SELECT %s FROM %s", strings.Join(selectClauses, ", "), "vote")
	if whereClause != "" {
		query += " WHERE " + whereClause
	}
	query += " GROUP BY " + groupClause
	rows, err := svc.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var results []map[string]interface{}
	columns, _ := rows.Columns()
	for rows.Next() {
		vals := make([]interface{}, len(columns))
		dest := make([]interface{}, len(columns))
		for i := range vals {
			dest[i] = &vals[i]
		}
		if err := rows.Scan(dest...); err != nil {
			return nil, err
		}
		rowMap := map[string]interface{}{}
		for i, col := range columns {
			rowMap[col] = vals[i]
		}
		results = append(results, rowMap)
	}
	return results, nil
}

// Helper functions used by services

// buildWhere assembles SQL WHERE clause and args
func buildWhere(where map[string]interface{}) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := 1
	for k, v := range where {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, " AND "), args
}

// buildWhereOffset is like buildWhere but starts binding at offset
func buildWhereOffset(where map[string]interface{}, start int) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := start
	for k, v := range where {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, " AND "), args
}

// buildInsert assembles INSERT columns, placeholders, and args
func buildInsert(data map[string]interface{}) ([]string, []string, []interface{}) {
	var cols []string
	var placeholders []string
	var args []interface{}
	i := 1
	for k, v := range data {
		cols = append(cols, k)
		placeholders = append(placeholders, fmt.Sprintf("$%d", i))
		args = append(args, v)
		i++
	}
	return cols, placeholders, args
}

// buildSet assembles SET clause and args
func buildSet(data map[string]interface{}, start int) (string, []interface{}) {
	var clauses []string
	var args []interface{}
	i := start
	for k, v := range data {
		clauses = append(clauses, fmt.Sprintf("%s = $%d", k, i))
		args = append(args, v)
		i++
	}
	return strings.Join(clauses, ", "), args
}

// scanDest returns a slice of pointers for scanning into struct fields
func scanDest(m interface{}) []interface{} {
	// leverage reflection or generate this per-model if needed
	return []interface{}{ /* generated per-model field pointers */ }
}
